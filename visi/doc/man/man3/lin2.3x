.TH LIN2 3x LINLIB
.SH ИМЯ
lin2, cp_set, at_set, cp_sav, cp_fet,
bell, er_eol, er_eop, er_pag, er_scr, r_key, r_cod, unr_c
\- БИБЛИОТЕКА linlib, УПРАВЛЕНИЕ ЭКРАНОМ И КЛАВИАТУРОЙ
.SH
.ES
 +----------+   БИБЛИОТЕКА ВВОДА-ВЫВОДА
(c) linlib  !   ДЛЯ АЛФАВИТНО-ЦИФРОВЫХ
 +----------+   ВИДЕОТЕРМИНАЛОВ
.EE
.SH ФОРМАТ
.ES 5

#include <stdio.h>
#include <line.h>

cp_set(nr, nc, at)
int nr;         /* номер строки  1...24 */
int nc;         /* номер колонки 1...80 */
int at;         /* слово атрибутов */

at_set(at)
int at;         /* слово атрибутов */

cp_sav()
cp_fet()

bell()

er_eol()        /* стереть до конца строки */
er_eop()        /* стереть до конца экрана */
er_pag()        /* стереть весь экран */

er_scr(from, to)
int from, to;

kbcod r_key()

kbcod r_cod(cod)
kbcod cod;      /* физический код клавиши */

unr_c(cod)
kbcod cod;

.EE
.SH ОПИСАНИЕ
.SI
.PP
Функция cp_set() используется для прямой адресации
курсора в пределах экрана.
Значения аргументов обрезаются до максимальных,
соответствующих размеру экрана, описанному в termcap.
Кординаты положения курсора задаются парой аргументов.
Начало кооординат (HOME) расположено в левом верхнем углу
экрана, его координаты (0,0).
.PP
Можно номер строки и позиции курсора задавать от конца, например
для экрана в 24 строки по запросу
.EX cp_set(-1, 5, 0);
курсор будет установлен в 5-ю позицию 23-й строки,
атрибут не изменится.
.PP
Значения слова атрибутов определены в файле line.h,
и подробно описаны в lin3(3x).
Для вызова функции cp_set из прикладных программ имеет смысл
пользоваться только атрибутами видео и, в комбинации с ними,
атрибутом INP.
.PP
остальные атрибуты предназначены для использования
в функциях управления экранными формами (см lin3(3x)).
.PP
Код управления атрибутами выдается на терминал только
при их смене, для снижения загрузки каналов связи.
.PP
Иногда удобнее изменить только атрибут, не меняя положения
курсора, для чего предназначена функция at_set.
Ее единственный параметр совпадает по формату и назначению
с аналогичным параметром функции cp_set.
.SS "поддержка асинхронных заданий"
Функция cp_sav() "запоминает" положение и атрибуты курсора,
как они были установлены последним вызовом cp_set().
Функция cp_fet() устанавливает положение и атрибуты,
"вспоминая" информацию, полученную cp_sav().
.SS "СИГНАЛ"
Функция bell предназначена для выдачи сигнала на терминал.
Обычно для этой цели используется звонок, однако это
может быть и кратковременное реверсирование фона.
Предпочтение отдается изменению фона.
Если в базе termcap не описана ни одна из этих возможностей,
то функция bell ничего не делает.
.SS "управление стиранием экрана"
Функция er_pag() устанавливает курсор в левый
верхний угол (HOME) и гасит экран.
Функции er_eop() и er_eol() не изменяют положения курсора.
.PP
Функция er_scr предназначена для стирания участка экрана на полную ширину
строки, принимает два аргумента - номера первой и последней
стираемой строки.
.SS "получить код клавиши"
Функция r_key() возвращает код, не зависящий от типа терминала.
Для хранения кода используется тип kbcod, который об'явлен в
файле "line.h". Для проверок на совпадение
с печатаемыми кодами можно
использовать обычные символьные константы (в простых кавычках) и
макросы из файла ctype.h.
Все непечатаемые коды, включая коды клавиш курсора и
дополнительных функциональных клавиш,
получают читабельные коды:
.ES
 '^A' ... '^\\'  коды от 001 до 037;
.EE
.PP
Все функциональные клавиши, которые закодированы в termcap,
получают код, совпадающий с ключом базы termcap, который
занимает две литеры, но кодируется как одна константа типа kbcod.
.ES
'do'  - стрелка вниз
'le'  - стрелка влево
'k1'  - клавиша "F1" ("PF1")
.EE
.PP
При каждом обращении функция r_key высвобождает буфер потока
stdout, используя функцию fflush из stdio. Функция может
вернуть какое-либо значение только после нажатия клавиши,
хотя во время ожидания ввода могут выполняться
асинхронные задания (см. ajobs(3x)).
.PP
Функция r_cod преобразует полученное от r_key значение
к логическому типу, см. visi(3x). Если не установлено соответствие
физического и логического кода, то возвращается физический код.
Кроме того,
так как наиболее часто используется логическое значение
кода клавиши, предусмотрен прозрачный вызов r_key непосредственно
через функцию r_cod, для чего ее надо вызвать с аргументом, равным нулю.
В файле "line.h" об'явлены стандартные значения, возвращаемые
функцией r_cod:
.ES
#define UPWARD     'AU'   /* "вверх" */
#define DOWN       'AD'   /* "вниз" */
#define LEFT       'AL'   /* "влево" */
#define RIGHT      'AR'   /* "вправо" */
#define GOLD       'GL'   /* префикс,
			   "золотая кнопка" */
#define HELP       'HE'   /* выдача подсказки */
#define ALTKEYPAD  'KP'   /* дополнит. клавиатура */
#define ENTER      'NL'   /* ввод строки */
#define DELETE     'DE'   /* забой */
#define REFRESH    'RE'   /* освежить экран */

.EE
.PP
Функция unr_c позволяет вернуть уже прочитанный логический код клавиши
назад функции r_cod. По своей сути эта функция
аналогична функции ungetc стандартной библиотеки, и точно так же
не позволяет возвращать более одного кода до очередного использования
r_cod (сохраняется только последний).
.SH ФАЙЛЫ
.SH ДОПОЛНИТЕЛЬНЫЕ ССЫЛКИ
stdio(2), ldemo(1), linlib(3x), lin1(3x), lin3(3x), lin4(3x), ajobs(3x),
visi(3x), termlib(3x), termcap(5), ctype(3).
.SH ДИАГНОСТИКА
.PP
На многотерминальных комплексах в периоды большой
загрузки системы случаются пропадания символов, принимаемых от
клавиатуры, особенно от функциональных клавиш, которые генерируют
несколько байт подряд. Функция r_key() пытается игнорировать
плохие кодовые последовательности, возвращая ноль,
но мусор все-таки иногда пролезает.
