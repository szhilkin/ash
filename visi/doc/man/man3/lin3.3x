.TH LIN3 3x LINLIB
.SH ИМЯ
lin3, e_str, r_str, e_tst, w_line, r_line, w_page, r_page
\- БИБЛИОТЕКА LINLIB, УПРАВЛЕНИЕ СТРАНИЦАМИ эКРАНА
.SH
.ES
 +----------+   БИБЛИОТЕКА ВВОДА-ВЫВОДА
(c) linlib  !   ДЛЯ АЛФАВИТНО-ЦИФРОВЫХ
 +----------+   ВИДЕОТЕРМИНАЛОВ
.EE
.SH ФОРМАТ
.ES

#include <line.h>

e_str(str, size, ctst, ofsp)
char    *str;      /* СТРОКА ДЛЯ РЕДАКТИРОВАНИЯ*/
int     size;      /* РАЗМЕР ПОЛЯ РЕДАКТИРОВАНИЯ */
kbcod   (*ctst)(); /* ТЕСТ ДЛЯ ВВОДА ПЕЧАТАЕМЫХ КОДОВ */
int     *ofsp;     /* УКАЗАТЕЛЬ НА ВЕЛИЧИНУ СМЕЩЕНИЯ
		    *             ОТ НАЧ. ПОЛЯ */

kb_cod
e_tst(cod, size, i)
kb_cod  cod;    /* код нажатой клавиши */
int     size;   /* размер поля */
int     i;      /* значение смещения курсора */

int allcod;     /* переход к редактированию по любой клавише */
kbcod
r_line(line, posp)
LINE    *line; /* УКАЗАТЕЛЬ НА ЛИНИЮ */
int     *posp; /* ПОЗИЦИЯ, С КОТОРОЙ
		* НАЧАТЬ РЕДАКТИРОВАТЬ */

w_line(line)
LINE *line;

kbcod
r_page(line_e, page, posp)
LINE    *line_e; /* СТРАНИЦА ДЛЯ РЕДАКТИРОВАНИЯ  */
LINE   **page;   /* ТЕКУЩАЯ ЛИНИЯ (СТАТУС)       */
int    *posp;    /* ПОЗИЦИЯ КУРСОРА
		  * ПРИ РЕДАКТИРОВАНИИ */

w_page ( line_e, cod )
LINE    *line_e;
kbcod cod;

.EE
.SH ОПИСАНИЕ
.PP
В этом разделе описаны средства высокого уровня
библиотеки LINLIB и редактор строки, который
можно использовать самостоятельно, без остальных функций
высокого уровня.
.PP
основные понятия и терминология
приведены в ldemo(1) и
linlib(3x).
.SS "e_str - редактор строки"
.PP
Редактирование начинается с показа старого содержимого
строки, остаток строки дополняется пробелами. Начальная
позиция и видеоатрибуты остаются от последнего вызова
функции cp_set (см. lin2(3x)). Можно пользоваться
альтернативным именем этой функции r_str.
.PP
Первый аргумент функции - указатель на строку, которая будет
редактироваться. длина строки должна быть не меньше ширины поля,
указываемой вторым аргументом. Пробелы в конце строки заменяются
на признак конца строки (ноль).
.PP
третьим аргументом можно указать ноль, если не надо
использовать дополнительную функцию для проверки функциональных клавиш.
Эта функция
вызывается из редактора строки при получении очередного кода
клавиши. Функция должна возвращать следующие значения:
.JP 0
если код не меняет содержимое строки;
.JP -1
если закончить редактирование;
.JP "код нажатой клавиши"
если данный символ должен изменять
содержимое редактируемой строки.
.PP
Функция проверки пишется пользователем, ее формат
приведен выше (функция e_tst).
.PP
Последним аргументом функции e_str стоит
указатель на счетчик позиции курсора в строке.
Через указатель счетчик модифицируется при
изменении положения курсора во время редактирования.
При вызове редактора курсор встанет в позицию, заданную
счетчиком.
При выходе из редактора счетчик содержит значение смещения
курсора относительно начала строки на момент завершения редактирования.
Если указатель на счетчик позиции равен нулю, то при вызове редактора курсор
встанет в нулевую позицию, а по этому "адресу", естественно, ничего
не оставит по окончании редактирования.
.SS "функции высокого уровня библиотеки LINLIB"
.PP
Структура данных описания экранной формы (страницы) и ее
полей (линий) об'явлена в файле line.h как тип
LINE:
.ES
typedef struct  { /* см. файл line.h */
 bool  size;       /* размер */
 bool  line;       /* строкa */
 bool  colu;       /* колонкa */
 bool  flag;       /* задержки */
 short attr;       /* атрибуты */
 char  *cvts;      /* формат (printf) */
 char  (*cvtf)();  /* формат 2 */
 int   (*test)();  /* проверка */
 char  *varl;      /* переменная */
} LINE;

.EE
.SS "w_line - Write LINE - вывод линии"
Вывод линии line осуществляется в виде строки
символов, занимающей
size позиций, в строке экрана line,
начиная с позиции colu.
.PP
В поле attr описываются атрибуты линии, в том числе
видеоатрибуты. Для совместимости с терминалами,
не оснащенными видеоатрибутами, linlib имеет
аппарат подсказок (promter) и достаточно жесткую связь
визуального изображения линии с ее логическим типом.
Введено такое понятие, как "логический видеоатрибут",
например атрибут для вывода текста, атрибут для вывода
поля меню, атрибут для ввода переменной.
Пользователь может по своему усмотрению изменить
набор подсказок и
визуальное представление каждого логического видеоатрибута,
при помощи программы vhset, см. vhset(1).
.PP
Возможные значения атрибутов описаны в файле "line.h".
Атрибуты делятся условно на две группы:
.JP "ВИДЕОАТРИБУТЫ"
Эти атрибуты задают визуальные свойства выводимого текста
в терминах логических атрибутов.
Видеоатрибуты нельзя комбинировать
между собой, при описании линии в поле attr должен быть только
один из них.
.JP "ОБЩИЕ ФЛАГИ И МАСКИ"
Используются в комбинации, требуемой для данного конкретного
типа поля, возможно создание новых типов линий.
Наиболее часто встречающиеся комбинации для основных типов
линий определены в этом же файле:
.ES
LTXT - комментарий
LHDR - заголовок
LVAR - переменная
LALT - переключатель
LMSE - селектор меню
.EE

.PP
Если задан флаг PMT, первая слева
позиция будет содержать подсказку. Подсказка выводится за
счет полезного размера поля.
.PP
Если к данному полю экранной формы нужно будет подводить курсор,
необходимо задать атрибут INP.
.PP
Остальные атрибуты достаточно подробно описаны в комментариях файла
"line.h".
Здесь описан алгоритм работы функции w_line.
.PP
Перед выдачей на экран формируется выводная строка.
.JP
Если поля форматов нулевые, то копируется содержимое
строки символов, на которую указывает varl.
.JP
Иначе если задан хотя бы один из форматов cvtf или cvts
(предпочтение отдается cvtf), в выводную строку
заносится результат форматного преобразования.
.JP
после формирования выводной строки она
усекается
до размеров size.
.JP
Результат центрируется, если заказан флаг MID, затем
дополняется пробелами, если указан PAD.
.JP
В завершение устанавливаются согласно описанию
курсор и видеоатрибуты, после чего
выводная строка передается на экран.

.SS "r_line() - Read LINE - чтение линии"
.PP
Эта функция достаточно редко применяется самостоятельно, обычно
она вызывается через функцию r_page. Здесь описан алгоритм
работы функции:
.JP
вызывается w_line для показа начального содержимого переменной,
связанной с линией.
.JP
первая нажатая клавиша влияет на дальнейшие действия, переход
в режим редактирования строки возможен для полей типа
.EX LTXT, LHDR, LVAR.
Можно по-разному организовать переход к фазе редактирования,
либо только по ограниченному набору клавиш, как это сделано
в ldemo, либо по любой печатной (исключая управляющие коды).
Для этого служит глобальный флаг allcod, который можно объявить
либо нулем (переход по пробелу и забою), либо единицей,
то есть по любому символу.
.JP
Второй аргумент нужен редактору строки (см. описание выше).
.JP
после завершения редактирования выполняются форматные
преобразования, и если при этом возникает ошибка,
то редактирование продолжается.
.JP
запускается тестирующая функция, написаная пользователем.
Если она возвращает FALSE, то
работа функции начинается с самого начала, а возврата из функции r_line
не происходит (см. ниже).
.JP
вызывается w_line для показа нового содержимого переменной,
связанной с линией.
.JP
если тестирующая функция вернула TRUE,
функция r_line возвращает код последней нажатой клавиши.
.JP "ПРИМЕЧАНИЕ"
если поля структуры типа LINE, в которых указывается
формат, тест имеют нулевые значения, то соответствующие
действия пропускаются.
.IP
.SS "w_page() - Write PAGE - вывод страницы (формы)"
.PP
для удобства работы отдельные линии обычно
об'единяют в страницы (формы). Страница, как правило,
содержит следуюшие элементы:
.JP
заголовок;
.JP
комментарии;
.JP
линии, доступные для ввода (редактирования);
.PP
При выводе страницы будут показаны все линии. При чтении
страницы курсор можно подвести только к линиям,
которые об'явлены доступными для ввода, для чего
в поле attr каждой такой линии
должен быть указан флаг INP (см. line.h)).

.PP
При выводе страницы осуществляется два прохода. Линии, доступные
для ввода, выводятся на втором проходе. Во время вывода таблиц
(см. ниже r_page()),
происходит их настройка.
.SS "r_page() - Read PAGE - читать страницу (форму)"
.PP
Функция предназначена для организации фазы обхода линий
страницы.
При каждом обращении читается одна линия, для чего
вызывается функция r_line(). Вторым аргументом в эту функцию передается
указатель на текущую линию.
Перед первым обращением (для данной страницы)
к r_page() необходимо
привести указатель на текущую линию
в правдоподобное состояние (можно ноль).
.PP
Внутри функции r_page() после каждого обращения
к r_line() производятся
следующие действия:
.JP
Для реализации фазы обхода линий
по нажатию клавиш управления курсором вычисляется
новое значение указателя для следующего обращения
к r_page(). При этом отыскивается
указатель на линию, размещенную на экране
рядом в нужном направлении,
либо, через зацикливание, с противоположного
конца той же строки или столбца.
По команде "НОВАЯ СТРОКА"
(возврат каретки или перевод строки)
переход осуществляется к
следущей линии, в порядке описания страницы.
В конце страницы выполняется зацикливание на начало.
Эти действия пропускаются, если
определены соответствующие флаги задержек.
.JP
Возвращается код последней нажатой клавиши,
полученный от r_line().

.SS "особенности работы с таблицами"
В языке Си редко используются массивы с размерностью
больше 1.
Рассмотрим типичный пример.
Нужно иметь доступ к таблице пар значений, минимум и максимум
некоторого параметра, всего 10 пар значений:
.ES

struct table {
	int min;
	int max;
	} tab[10];
.EE
Адреса, которые нужны для доступа к каждому
из элементов, записываются так:
.ES
&tab[0].min, &tab[0].max,
&tab[1].min, &tab[1].max,
&tab[2].min, &tab[2].max, и т.д.
.EE
.PP
Попробуем описать доступ к ним через экран. Допустим, поля для ввода
будут размещены со строки 10,
каждая пара в одной строке экрана, каждая следующая пара
в тех же позициях, но на одну строку ниже. Размер поля для изображения
каждого значения 6 позиций.
.ES 1

#include "line.h"

LINE  line[] = {
/* пример страницы для доступа к таблице */
{ 6,10,25, 0, INP|VARL, "%6d", 0, 0, &tab[0].min, },
{ 6,10,35, 0, INP|VARL, "%6d", 0, 0, &tab[0].max, },

{ 6,11,25, 0, INP|VARL, "%6d", 0, 0, &tab[1].min, },
{ 6,11,35, 0, INP|VARL, "%6d", 0, 0, &tab[1].max, },

 ...  ...  ...

{ 6,19,25, 0, INP|VARL, "%6d", 0, 0, &tab[9].min, },
{ 6,19,35, 0, INP|VARL, "%6d", 0, 0, &tab[9].max, },

{ 0 }, };    /* конец страницы */

.EE
.PP
Как нетрудно заметить, описание почти в точности повторяется через каждые
2 строки. Изменяются значения только двух полей:
.EX line[i].line и  line[i].varl.
Изменения первого очевидны, а разность между
.EX &tab[0].min и &tab[1].min,
либо между
.EX &tab[0].max и &tab[1].max,
есть не что иное, как размер структуры
tab[i], который в языке Си записывается с помощью операции
sizeof.
В linlib предусмотрены средства для более наглядного
и менее подверженного различным ошибкам описания,
которое станет ясно из следующего примера:
построим описание для доступа к той же таблице:
.ES

#include "line.h"

#define SZTAB sizeof(tab[0])

LINE line[] = {

{ 6,10,25,0, INP|VARL|TBL,"%6d",0,0,&tab[0].min },
{ 6,10,25,0, INP|VARL|TBL,"%6d",0,0,&tab[0].max },

{ 6,11,25,SUSUP|SUST,   0,    0,0,0,SZTAB  },
{ 6,11,25,SUSUP|SUST,   0,    0,0,0,SZTAB  },
	. . .

{ 6,19,25,SUSUP|SUST,   0,    0,0,0,SZTAB  },
{ 6,19,25,SUSUP|SUST,   0,    0,0,0,SZTAB  },
{ 0 }, };

.EE
.PP
Первые две линии являются "базой" таблицы. В следующих строках
описания помещается только информация о размещении на экране
а также
информация о том, что эта линия не является базой (флаг SUST) и
в каком направлении искать базу (флаг SUSUP).
Здесь же помещается информация о величине смещения.
Преимущества такого способа описания
таблиц проявляются при использовании препроцессора vcc(1),
который позволяет свести к минимуму время подготовки описания страницы.
.PP
В общем случае в таблицу
может входить произвольное количество базовых линий,
"размножать" их можно и по столбцу и по строке,
но они должны идти подряд (во всех должен стоять флаг TBL).
.SH ЗАМЕЧАНИЯ
.JP
Все тонкости работы с функциями высокого уровня невозможно
описать, рекоменуется пользоваться исходными текстами
демонстрационной программы ldemo(1).
.JP
Наверное, не совсем удачно выбран термин "линия" и соответствующие
идентификаторы.
.JP
Описания таблиц имеют смысл только при использовании функций
r_page() и w_page(), флаг TBL игнорируется функциями
w_line() и r_line().
Кроме того, важно иметь в виду, если страница содержит описания
таблиц, то надо обязательно воспользоваться функцией
w_page прежде, чем вызывать для нее r_page.
.JP
На первый взгляд все это может показаться настолько странным и
замысловатым, что у Вас пропадет всякая охота заниматься
изучением системы. Такая точка зрения вполне допускается,
и специально для бывших студентов, которые умеют "болванить"
курсовые проэкты, заготовлена куча примеров в виде исходных
текстов демонстрационной программы ldemo.
.SI
.SH ФАЙЛЫ
.SH ДОПОЛНИТЕЛЬНЫЕ ССЫЛКИ
stdio(2), ldemo(1), linlib(3x), lin1(3x), lin2(3x), lin4(3x), ajobs(3x),
vcc(1), visi(3x), termlib(3x), termcap(5)
.SH ДИАГНОСТИКА
